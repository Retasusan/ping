package main

import (
	"encoding/binary"
	"fmt"
	"log"
	"syscall"
)

type ICMPEcho struct {
	Type       uint8
	Code       uint8
	Checksum   uint16
	Identifier uint16
	Sequence   uint16
	Data       []byte
}

func (e *ICMPEcho) Marshal() []byte {
	// ICMP Echo header は 8 bytes
	b := make([]byte, 8+len(e.Data))

	// 0–1: Type, Code
	b[0] = e.Type
	b[1] = e.Code

	// 2–3: Checksum（今は 0 のまま）
	binary.BigEndian.PutUint16(b[2:4], e.Checksum)

	// 4–5: Identifier
	binary.BigEndian.PutUint16(b[4:6], e.Identifier)

	// 6–7: Sequence Number
	binary.BigEndian.PutUint16(b[6:8], e.Sequence)

	// 8–: Data
	copy(b[8:], e.Data)

	return b
}

func main() {
	fd, err := syscall.Socket(
		syscall.AF_INET,
		syscall.SOCK_RAW,
		syscall.IPPROTO_ICMP,
	)

	if err != nil {
		panic(err)
	}

	defer func() {
		if err := syscall.Close(fd); err != nil {
			log.Println("close failed:", err)
		}
	}()

	echo := &ICMPEcho{
		Type:       8,
		Code:       0,
		Checksum:   0,
		Identifier: 0x1234,
		Sequence:   1,
		Data:       []byte("hello"),
	}

	pkt := echo.Marshal()
	fmt.Printf("% x\n", pkt)

	fmt.Println("raw socket opened:", fd)
}
